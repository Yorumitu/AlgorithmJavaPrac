/**
 * 题目：给你一颗二叉树，树中的节点保存一个id，让你对这颗二叉树做k次操作[ak,bk]，每次操作选择对应序号ak的二叉树结点，对以这个节点为根的子树中的所有节点(初始值为0)做异或操作，返回k次操作之后的树。
 * 例如：给一棵二叉树[3,#,2,1]，k个操作[[1,3],[2,4],[3,5],[1,4]]，你需要(1)对id为3的节点以及所有孩子节点对5做异或(2)对id为2的节点以及所有孩子节点对4做异或(3)对id为1的节点以及孩子节点分别对3和4做两次异或。
 *
 * 注意点1：题目给的树的val保存的是id，这个id和题目给的k次操作的每次操作的第0个元素对应，所以这里最直接的想法就是你要构造一棵和题目给的树相同但节点val为0的树copy；
 * 注意点2：异或操作与顺序无关，对于[[1,2],[1,3],[1,4]]的操作，可以先处理为[[1,2^3^4]]=[[1,5]]
 */
public class xorChildOfTree {
}
