package 分糖;

/**
 * 给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。
 * 你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。
 *
 * 示例 1:
 * 输入: candies = [1,1,2,2,3,3]
 * 输出: 3
 * 解析: 一共有三种种类的糖果，每一种都有两个。
 * 最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。
 *
 *
 * 示例 2 :
 * 输入: candies = [1,1,2,3]
 * 输出: 2
 * 解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。
 *
 * 注意:
 * 数组的长度为[2, 10,000]，并且确定为偶数。数组中数字的大小在范围[-100,000, 100,000]内。
 *
 */
public class MaxCandyType {



}





/**
 * 题目解析
 * 总共有 n 个糖，平均分给两个人，每人得到 n／2 块糖，那么 能拿到的最大的糖的种类数也就是 n／2 种 ，不可能更多，只可能更少。
 * 所以只需要统计出糖的种类数，如果糖的种类数小于 n／2，说明拿不到 n／2种糖，最多能拿到的种类数就是当前糖的总种类数。最后，看（数量的一半）和（所有的种类）哪个先达到，取两者中较小的值即可。
 * 举个例子：
 * 极端情况1：所有糖都不重样，这种情况妹妹也只能拿到一半的糖果。
 * 极端情况2：只有一种糖，这种情况妹妹只能得到一种糖果。
 * 平均情况：每个糖都有两个，这种情况妹妹可以拿到所有种类，数量与 极端情况1 一样。
 *
 * 观察前面的 示例2 ，我们发现，题目并不简单：由博弈的思想，可以发现，我们必须尽可能的避免姐弟两人分得糖果种类可能一样的情况发生。
 * 如上，姐姐拿[1,3]或[1,4]，弟弟可以拿[1,4]或[1,3]，这时姐弟两人所得糖果种类相等，但我们要避免，所以，姐姐只能拿[3,4]。
 *
 * 由此可知，求糖果的种类数使用 hash 即可。（同样，利用hashset不保存相同值的特点）
 * -----------------------------------
 * ©著作权归作者所有：来自51CTO博客作者koaxios的原创作品，请联系作者获取转载授权，否则将追究法律责任
 * 巧解“博弈”型算法题：分糖果问题
 * https://blog.51cto.com/u_15296224/5655753
 *
 *
 *class Solution {
 *     public int distributeCandies(int[] candies) {
 *         Set<Integer> nums = new HashSet<>();
 *         for (int i = 0; i < candies.length; i++) {
 *             nums.add(candies[i]);
 *         }
 *         int numNums = nums.size();
 *         int numTarget = candies.length / 2;
 *         return numNums >= numTarget ? numTarget : numNums;
 *     }
 * }
 */
